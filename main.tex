\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage[margin=0.5in]{geometry}

\title{Software Interview Prep}
\author{tyang27}
\date{August 2019}

\begin{document}

\maketitle

\section{Topics}
\subsection{Sorting and searching}
\subsubsection{Insertion sort}
Preserves loop invariant by inserting next element right to cursor into sorted array.
\begin{itemize}
    \item Adaptive - good for mostly sorted data sets.
    \item Stable - preserves order.
    \item In-place - no auxillary data structures.
    \item Online - does not need whole input to start sorting.
\end{itemize}
\begin{verbatim}
    for (int cursor=1; cursor < A.length; cursor++) {
        int cursorVal = A[cursor];
        int left = cursor - 1;
        while (left >= 0 && A[left] > cursorVal) {
            A[left+1] = A[left];
            left--;
        }
        A[left+1] = cursorVal;
    }
\end{verbatim}

\subsubsection{Selection sort}
Preserves loop invariant by putting the next largest element right of cursor into sorted array.
\begin{verbatim}
    for (int cursor=0; cursor < A.length-1; cursor++) {
        int minIndex = cursor;
        for (int right = cursor+1; right < A.length; right++) {
            if (compare(A[minIndex], A[right])
                minIndex = right;
        }
        if (minIndex != cursor)
            swap(A, cursor, minIndex);
    }
\end{verbatim}


\subsubsection{Bubble sort}
\subsubsection{Merge sort}


\subsubsection{Quick sort}

\begin{itemize}
    \item Count sort
    \item Radix sort
    \item Search
\end{itemize}

\subsection{Hash Tables}
\begin{itemize}
    \item Using only arrays
\end{itemize}

\subsection{Coding}
\begin{itemize}
    \item Java
    \item APIs
    \item OOP
    \item Testing
    \item Corner and edge cases
\end{itemize}

\subsection{Algorithms}
\begin{itemize}
    \item Bottom up
    \item Top down
    \item Analyze complexity, how to improve
    \item Divide and conquer
    \item Dynamic programming
    \item Memoization
    \item Greedy
    \item Recursion
    \item Data structure specific
\end{itemize}

\subsection{Data Structures}
\begin{itemize}
    \item Arrays
    \item Linked lists
    \item Stacks
    \item Queues
    \item Hash set
    \item Hash map
    \item Trees
    \item Binary tree
    \item Heap
    \item Graph
\end{itemize}

\subsection{Mathematics}
\begin{itemize}
    \item Counting
    \item Probability
\end{itemize}

\subsection{Trees and Graphs}
\begin{itemize}
    \item Binary tree
    \item N-ary tree
    \item Trie tree
    \item Balanced BST
    \item Graph using objects
    \item Graph using adjacency list
    \item Graph using adjacency matrix
    \item BFS
    \item DFS
    \item Preorder, inorder, postorder
\end{itemize}

\subsection{Recursion}

\subsection{Operating Systems}
\begin{itemize}
    \item Processes
    \item Threads
    \item Concurrency issues
    \item Locks
    \item Mutexes
    \item Semaphores
    \item Monitors
    \item Deadlock
    \item Livelock
    \item Context switching
    \item Scheduling
\end{itemize}

\subsection{System Design}
\begin{itemize}
    \item Breaking down a problem into subproblems
    \item Engineering tradeoffs
\end{itemize}

\subsection{Development Practices and Open-Ended Discussion}
\begin{itemize}
    \item Validating designs
    \item Testing whiteboard code
    \item Preventing bugs
    \item Code maintainability and readability
    \item Refactor/review sample code
    \item Biggest challenge faced
    \item Best/worst design seen
    \item Performance analysis and optimization
    \item Testing and ideas for improving existing products
\end{itemize}

\end{document}
