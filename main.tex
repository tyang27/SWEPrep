\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    tabsize=2,
    showstringspaces=false,
    keywordstyle=\color{blue},
    basicstyle=\ttfamily
}


\title{Software Interview Prep}
\author{tyang27}
\date{August 2019}

\begin{document}

%\maketitle

\section{Topics}
\subsection{Sorting and searching}
\subsubsection{Insertion sort - $O(n^2)$}
Preserves loop invariant by inserting next element right of cursor into invariant.
\begin{itemize}
    \itemsep0em 
    \item Adaptive - good for mostly sorted data sets.
    \item Stable - preserves order of equal items.
    \item In-place - no auxillary data structures.
    \item Online - does not need whole input to start sorting.
    \item Insertion finding step can be sped up with binary search.
\end{itemize}
\begin{lstlisting}[language=java]
void sort(int[] A) {
    for (int cursor=1; cursor < A.length; cursor++) {
        int cursorVal = A[cursor];
        int left = cursor - 1;
        while (left >= 0 && A[left] > cursorVal) {
            A[left+1] = A[left];
            left--;
        }
        A[left+1] = cursorVal;
    }
}
\end{lstlisting}

\subsubsection{Selection sort - $O(n^2)$}
Preserves loop invariant by putting the next largest element right of cursor as next element of invariant.g
\begin{lstlisting}[language=java]
sort(int[] A) {
    for (int cursor=0; cursor < A.length-1; cursor++) {
        int minIndex = cursor;
        for (int right = cursor+1; right < A.length; right++) {
            if (compare(A[minIndex], A[right])
                minIndex = right;
        }
        if (minIndex != cursor)
            swap(A, cursor, minIndex);
    }
}
\end{lstlisting}

\begin{comment}
\subsubsection{Bubble sort}
Not very good or interesting...
\end{comment}

\subsubsection{Merge sort - $O(n\log n)$}
Partition into smaller and smaller arrays, then merge to sort.
\begin{lstlisting}[language=java]
void sort(int[] A) {
    if (A.length <= 1) return;
    
    int mid = A.length/2;
    int[] left = new int[mid];
    int[] right = new int[A.length-mid];
    
    System.arraycopy(A, 0, left, 0, mid);
    System.arraycopy(A, mid, right, 0, A.length-mid);
    sort(left);
    sort(right);
    merge(A, left, right);
}
void merge(int[] A, int[] left, int[] right) {
    int l, r, i; l = r = i = 0;
    while (l < left.length || r < right.length) {
        if (l < left.length && r < r.length)
            A[i++] = compare(left[l], right[r]) ? right[r++] : left[l++];
        else if (l < left.length)
            A[i++] = left[l++];
        else if (r < right.length)
            A[i++] = right[r++];
    }    
}
\end{lstlisting}

\subsubsection{Quick sort - $O(n^2)$ worst case, $O(n\log n)$ average case}
Partition into higher and lower group, then recursively sort.
\begin{lstlisting}[language=java]
void sort(int[] A, int low, int high) {
    if (high < low) return;
    int pivot = partition(A, low, high);
    sort(A, low, pivot-1);
    sort(A, pivot+1, high);
}
void partition(int[] A, int low, int high) {
    int lessThan = low-1;
    int curr = low;
    for (; curr < high; curr++)
        // Use A[high] as pivot.
        if (A[curr] <= A[high]) swap(A, ++lessThan, curr);
    swap(A, ++lessThan, high);
    return lessThan;
}
\end{lstlisting}

\subsubsection{Count sort - $O(n+r)$}
Count frequencies of each element, then unpack.
\begin{lstlisting}[language=java]
void sort(int[] A) {
    if (A.length == 0) return;
    int min = Arrays.stream(A).min().getAsInt();
    int max = Arrays.stream(A).max().getAsInt();
    int[] counts = new int[max-min+1];
    for (int i : A) counts[i-min]++;
    
    int j = 0;
    for (int i=0; i < A.length; i++) {
        while (counts[j] == 0) j++;
        A[i] = min + j;
        counts[j]--;
    }
}
\end{lstlisting}

\subsubsection{Radix sort - $O(nk/d)$}
Radix sort with strings. I didn't realize it would sort by length and then alaphabetical, so it's kind of dumb.
\begin{lstlisting}[language=java]
void mySort(String[] S) {                                  
    for (int i = 0; i < MAX_LEN; i++) {                                    
        // Initialize buckets                                                
        List<List<String>> B = new ArrayList<>(BUCKETS);                  
        for (int b = 0; b < BUCKETS; b++)
            B.add(new ArrayList<>());                                       
        // Sort into buckets                                       
        for (String s : S)                                           
            B.get(mapping(s, MAX_LEN - 1- i)).add(s);
        // Unpack
        for (int b = 0, unpacker = 0; b < BUCKETS; k++)                             
            for (String s : B.get(b))
                S[unpacker++] = s;                           
    }
}
int mapping(String s, int i) { return (int) s.charAt(i) - (int) '`'; }
\end{lstlisting}

\subsubsection{Binary search - $O(\log n)$}
-1 if not found, or ceiling (highest number less than), or floor (lowest number greater than):
\begin{lstlisting}[language=java]
int search(int[] A, int key, int low, int high) {
    if (high < low) {
        // return low; // ceiling
        // return high; // floor
        return -1;
    }
    int mid = low + (high-low)/2;
    if (A[mid] == key) return mid;
    else if (A[mid] > key) return search(A, key, low, mid-1);
    else return search(A, key, mid+1, high);
}
\end{lstlisting}

\subsubsection{Median/order stats}
\textbf{Median of medians - $O(n)$ worst and best case}\\
\textbf{Quick select - $O(n^2)$ worst case but $O(n)$ average}\\
Partition, then recurse based on the size of partition created by pivot.
\begin{lstlisting}[language=java]
pubic static int search(int[] A, int k, int low, int high) {
    if (high == low) return A[low];
    int pivot = partition(A, low, high);
    if (k < pivot) return search(A, k, low, pivot-1);
    else if (k > pivot) return search(A, k, pivot+1, high);
    else return A[pivot];
}
\end{lstlisting}

\subsubsection{Permutations}
\textbf{All - O(n!)}\\
Head recursion to the end so the last few numbers will be a permutation. Tail recursion to reset it to the last state.
\begin{lstlisting}[language=java]
void permute(int[] A, int low, int high) {
    if (low == high) {
        permutations.add(Arrays.copyOf(A, A.length));
        return;
    }
    for (int curr=low; curr <= high; curr++) {
        swap(A, low, curr);
        permute(A, low+1, high);
        swap(A, curr, low);
    }
}
\end{lstlisting}
Next permutation: TODO

\subsection{Hash Tables}
\subsubsection{Dynamic - $O(1)$ average, $O(n)$ worst case}
\begin{itemize}
    \itemsep0em
    \item Capacity - initial size of primary array.
    \item Load factor - what percentage fill to resize.
    \item Separate chaining - use list for collision.
    \item Linear, quadratic chaining - use $+k$, $_k^2$.
    \item Cuckoo - kick out element.
    \item Bloom filter - use multiple hash to create fingerprint for keys, faster retrieval if not exist.
\end{itemize}
\begin{lstlisting}[language=java]
    class Dictionary {
        List<List<Pair>> d = new ArrayList<>();
        int capacity;
        int hash(int key) { return Math.abs(key) % capacity; }
        Dictionary(int capacity) {
            this.capacity = capacity;
            for (int i=0; i < capacity; i++) d.add(new ArrayList<Pair>());
        }
        void put(int key, String value) {
            for (Pair p : d.get(hash(key))) {
                if (p.key == key) {
                    p.value = value;
                    return;
                }
            }
            d.get(hash(key)).add(new Pair(key, value));
        }
        String get(int key) {
            for (Pair p : d.get(hash(key))) {
                if (p.key == key)
                    return p.value;
            }
            return null;
        }
    }
\end{lstlisting}

\begin{comment}
\subsubsection{Static}
If you know the keys ahead of time, use primary hash function to find out where they go to, then build secondary perfect hash functions. This will be $O(1)$ worst case and $O(n)$ space, since you know ahead of time how large to make your secondary arrays.
\end{comment}

\subsection{Coding}
\subsubsection{Java}
\begin{itemize}
    \itemsep0em
    \item Lambdas:
    \begin{lstlisting}[language=java]
    (T1 t1, ...) -> { t1...};
    \end{lstlisting}
    \item Streams:
    \begin{lstlisting}[language=java]
    collection.stream()
        .map(lambda) //1:1
        .flatMap(lambda) //1:*
        .forEach()
        .sorted()
        .distinct()
        .filter(lambda).
        .concat(stream)
        .limit(int)
        .toArray()/.collect(Collectors.toList());
    \end{lstlisting}
\end{itemize}

\subsubsection{REST APIs}
\begin{itemize}
    \itemsep0em
    \item No saved state e.g. with HTTP
    \item Everything is in the query which is good for scalability and indepenent growth of client server
    \item GET, POST, PUT, DELETE
\end{itemize}

\subsubsection{OOP}
\begin{itemize}
    \itemsep0em
    \item Extending a base class or abstract class, or implementing an interface.
    \item Encapsulation\\
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
         & class & package & subclass & subclass & world \\
         & & & same pkg & diff pkg &\\
         \hline
        public & Y & Y & Y & Y & Y\\
        protected & Y & Y & Y & Y & \\
        none (pkg-private) & Y & Y & Y & & \\
        private & Y & & & &\\
        \hline
    \end{tabular}
    \item Polymorphism - method overloading, method overriding
    \item Singleton - only one instance created, global access point.
\begin{lstlisting}[language=java]
class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}
// Usage: Singleton.getInstance();
\end{lstlisting}
    \item Factory - produce items that implement the same interface.
\begin{lstlisting}[language=java]
interface FactoryItem { }
class Item1 implements FactoryItem { }
class Factory {
    static FactoryItem buildItem(String type) {
        if (type.equalsIgnoreCase("Item1")) { return new Item1(); }
        return null;
    }
}
// Usage: FactoryItem item = Factory.buildItem(Item1");
\end{lstlisting}

\begin{comment}
    \item Builder - method chaining makes it easier to set multiple fields.
\begin{lstlisting}[language=java]
public class Item {
    private final int field1;
    private Item() {}
    Item(Builder builder) { field1 = builder.field1; }
    static class Builder {
        private int field1;
        private Builder();
        static Builder newInstance() { return new Builder(); }
        Builder setField1(int field1) {
            this.field1 = field1;
            return this;
        }
        Item build() { return new Item(this); }
    }
}
// Usage: Item.Builder.newInstance().setField1(1)./*...*/.build();
\end{lstlisting}

    \item Prototype
\begin{lstlisting}[language=java]
abstract class Item implements Cloneable {
    protected String itemName;
    abstract void addItem();
    public Object clone() {
        try {
            return super.clone();
        } catch (CloneNotSupporteException e) {
            e.printStackTrace();
        }
        return null;
    }
}
class Item1 extends Item {/*...*/}
class ItemStore {
    Map<String, Item> protoMap = new HashMap<>();
    static { protoMap.put("Item1", new Item1()); }
    public static Prototype getItem(String item) {
        return (Item) protoMap.get(item).clone();
    }
}
\end{lstlisting}
    \item Adapter
\begin{lstlisting}[language=java]
interface Male { abstract void beingDumb(); }
interface Female { abstract void beingSmart(); }
class male1 implements Male {}
class female1 implements Female {}
class Adapter {
    Male m;
    Adapter(Male male) { this.m = m; }
    public void beingSmart() { m.beingDumb(); }
}
// Usage: Adapter(new Male()).beingSmart(); --> new Female().beingSmart();
\end{lstlisting}
    \item State - uses polymorphism to change the behavior of the object.
\begin{lstlisting}[language=java]
interface State { public void fx(Context ctxt); }
class State1 implements State {/*...*/}
class Context {
    private State currentState;
    Context() { currentState = new State1(); }
    void setState(State state) { currentState = state; }
    void fx() { currentState.fx(this); }
}
// Usage: Context c = new Context(); c.setState(new State2()); c.fx();
\end{lstlisting}
    %\item Strategy
    \item Observer
\begin{lstlisting}[language=java]
class Display {
    private int field1;
    void update(int field1) { field1 = field1; display(); }
    void display() {/*...*/}
}
class Data {
    Display display;
    private int field1;
    Data(Display display) { display = display; }
    void updateField1() {/*...*/}
    void dataChanged() { display.update(field1); }
}
\end{lstlisting}
    \item Visitor
\begin{lstlisting}[language=java]
interface Visitor { void visit(Boyfriend bf); void visit(Bestfriend f); }
interface Friend { void sleepover(Visitor visitor); }
class Boyfriend implements Friend {/*...*/}
class Bestfriend implements Friend {/*...*/}
class Me implements Visitor {/*...*/}
// Usage: Make an collection of Friends, and Me
//  for (Friend f : friends) friend.sleepover(me);
\end{lstlisting}
\end{comment}
\end{itemize}

\subsection{Algorithms}
\begin{itemize}
    \itemsep0em
    \item Bottom up vs top down
    \item Analyze complexity (Master's, induction), how to improve
    \item Divide and conquer
    \item Dynamic programming
    \item Memoization
    \item Greedy
\end{itemize}

\subsection{Data Structures}
\subsubsection{Collections}
\begin{itemize}
    \itemsep0em
    \item c.size(); [].length, String.length();
    \item Collections.binarySearch(List l, K k);
    \item Collections.fill(List l, V v);
    \item Collections.max/min(Collection c);
    \item Collections.replaceAll(List l, K old, K new);
    \item Collections.sort/reverse/shuffle(List l);
    \item Collections.swap(List l, int i, int j);
\end{itemize}
\subsubsection{Strings}
``initialization"
\begin{itemize}
    \itemsep0em
    \item Integer.valueOf(String s);
    \item String.valueOf(K k);
    \item s.charAt(int i);
    \item s.substring(int start, [int end]);
    \item s.replace(char src, char dst);
    \item s.indexOf(char c);
    \item s.matches(String regex);
    \item s.split(String regex);
    \item s.startsWith(String pre); s.endsWith(String suf);
\end{itemize}
\subsubsection{Arrays/linked lists}
new ArrayList(); or new LinkedList(); or new T[]; or {}; or Arrays.asList(,,); or Arrays.asList(t1, ...)
\begin{itemize}
    \itemsep0em
    \item Arrays.toString(T[]);
    \item System.arrayCopy(T[] src, int srcStart, T[] dst, int dstStart, int length);
    \item a.get(int i); a.set(int i, T t);
    \item a.add(T t); a.addAll(List l); a.remove(int i);
    \item a.contains(T t); a.indexOf(T t);
\end{itemize}
\subsubsection{Stacks/queues/priority queue/heap}
new Deque(); or new PriorityQueue();
X can be First or Last.
\begin{itemize}
    \itemsep0em
    \item dq.offerX(T t) (push)
    \item dq.peekX() (get)
    \item dq.pollX() (pop)
\end{itemize}
\subsubsection{HashSet/HashMap}
new HashMap(); or new LinkedHashMap();
\begin{itemize}
    \itemsep0em
    \item m.containsKey(K k); m.containsValue(V v);
    \item Map.Entry entry : m.entrySet();
    \item m.keySet(); and m.values();
    \item m.get(K k); and map.put(K k, V v);
    \item m.remove(K k);
\end{itemize}
new HashSet();
\begin{itemize}
    \itemsep0em
    \item s.add(K k); s.remove(K k);
    \item s.contains(K k);
    \item s.toArray(); new ArrayList(s);
\end{itemize}
\subsection{TreeSet/TreeMap}
Red black tree, longer get, but ordered keys. Same operations as above, plus some\\
new TreeMap(); // Replace E with Entry, D with Map\\
new TreeSet(); // Remove E, D with Set
\begin{itemize}
    \itemsep0em
    \item m.firstE/lastE(K k);
    \item m.ceilingE/floorE(K k); // includes equal to
    \item m.higherE/lowerE(K k); // doesn't include equal to
    \item m.headD/tailD(K k, B b); or subD(K k1, B b1, K k2, B b2); (inclusive)
\end{itemize}

\subsubsection{Disjoint set}
Can easily create a mapping from an object to a value, but for simplicity just use index in range as the data.
\begin{lstlisting}[language=java]
class UnionFind {
    int[] rank, nodes;
    public UnionFind(int n) {
        rank = new int[n];
        nodes = new int[n];
    }
    public void create(int x) {
        nodes[x] = x;
        rank[x] = 0;
    }
    public int find(int x) {
        // Path compression
        if (x != nodes[x]) nodes[x] = find(nodes[x]);
        return nodes[x];
    }
    public boolean connected(int x, int y) { return find(x) == find(y); }
    public void merge(int x, int y) {
        int parentX = find(x);
        int parentY = find(y);
        // Union by rank
        if (rank[parentX] > rank[parentY]) {
            nodes[parentY] = parentX;
        } else if (rank[parentY] > rank[parentX]) {
            nodes[parentX] = parentY;
        } else {
            nodes[parentX] = parentY;
            rank[parentY]++;
        }
    }
}
\end{lstlisting}

\subsection{Mathematics}
\subsubsection{Counting}
\begin{itemize}
    \itemsep0em
    \item Ordered list without replacement - $\frac{n!}{(n-k)!}$
    \item Ordered list with replacement - $n^k$
    \item Subset without replacement - $\binom{n}{k} = \frac{n!}{k!(n-k)!}$
\end{itemize}
\subsubsection{Probability}

\subsection{Trees and Graphs}
\subsubsection{Binary tree}
\begin{lstlisting}[language=java]
class Node {
    int val; Node left, right;
    BinaryNode(int val) { this.val = val; }
    static void traverse(Node root) {
        //Preorder
        if (root.left != null) traverse(root.left);
        // Inorder
        if (root.right != null) traverse(root.right);
        // Postorder
    }
}
\end{lstlisting}
\subsubsection{N-nary tree}
Use array instead of left and right from above, or use an adjacency list graph.
\subsubsection{Trie tree}
TODO
\subsubsection{Balanced BST}
Find the place to insert, then insert as a leaf, as black if RB. Then, rotate up to fix AVL properties (height of subsequent nodes differ by at most 1) or to fix RB properties (black root, no subsequent red nodes, all paths contain same number of black nodes). Rotations: single rotate pushes the largest element down so that the center item is promoted, and double rotate first rotates the bottom two to get the center node in the middle, and then single rotates. Annoying, not that interesting to implement.
\subsubsection{Graph using objects}
Annoying, not that interesting to implement.
\subsubsection{Graph using adjacency list}
\begin{lstlisting}[language=java]
class Vertex {
    String key, value;
    Vertex(String key, String value) { this.key = key; this.value = value; }
    @Override
    public boolean equals(Object o) { return key.equals(((Vertex) o).key); }
}
class Graph {
    Map<Vertex, List<Vertex>> g;
    Graph() { g = new HashMap<Vertex, List<Vertex>>(); }
    Vertex vertex(String key, String val) {
        Vertex v = new Vertex(key, val);
        if (g.containsKey(v)) return null;
        g.put(v, new ArrayList<>());
        return v;
    }
    void edge(Vertex v1, Vertex v2) {
        if (g.get(v1.contains(v2)) return;
        g.get(v1).add(v2);
    }
    
}
\end{lstlisting}
\subsubsection{Graph using matrix}
\begin{lstlisting}[language=java]
class Graph {
    List<List<int>> g;
    List<String> nodes;
    Graph(List<String> nodes) {
        this.nodes = nodes;
        g = new ArrayList(nodes.size());
        for (int i = 0; i < nodes.size(); i++) {
            g.add(new ArrayList<List<String>>());
            for (int j = 0; j < nodes.size(); j++)
                g.get(i).add(-1);
        }
    }
    void edge(String v1, String v2, int val) {
        g.get(nodes.indexOf(v1)).set(nodes.indxOf(v2), val);
    }
}
\end{lstlisting}
\subsubsection{BFS, DFS, Topological Sort}
\begin{itemize}
    \item BFS uses queue, while DFS uses stack. Function calls are on a stack, so no other data structures needed.
    \item For topological sorting, intuition is that it is ordered by decreasing finishing time for DFS, so add a node that connects to all nodes without incoming edges. Then, run dfs on it, with tail call to add it to array.
\end{itemize}
\begin{lstlisting}[language=java]
// Assume vertex passed in is already marked as visited.
// Assume that the node passed in can reach every node.
// If not, keep searching unvisited nodes.
Deque<Vertex> dq = new ArrayDeque<>();
List<Vertex> sorted = new ArrayLost<>();
void bfs/dfs(Vertex v) {
    // Process node
    for (Vertex dst : g.get(v)) {
        if (!dst.val.equals("visited") {
            dq.offerLast(dst);
            dst.val = "visited";
        }
    }
    if (dq.size() != 0)
        bfs(dq.pollFirst()); // dfs(dq.pollLast());
}
void dfs(Vertex v) {
    // Process node.
    g.get(v).stream()
        .filter(x -> !x.val.equals("visited"))
        .map(x -> { x.val = "visited"; return x; }
        .forEach(x -> dfs(x));
    //topoSort.add(v);
}
\end{lstlisting}
\subsection{Strongly Connected Components}
Conceptually, two DFS modified to highlight edges that find decreasing last visit time between the nodes, one on the graph and one on the transpose; if highlighted in both runs, SCC. Implementation: DFS with tail call push onto stack (like topological sort, ordering by decreasing last visit time). Reverse directions of edges on graph. While stack is not empty, pop nodes and DFS on unvisited ones to get a single SCC. 
\subsection{Minimum Spanning Tree}
\begin{itemize}
    \itemsep0em
    \item Kruskal's: Store edges weights in a minheap (like sorting the edges). Create disjoint set for nodes. For each minimum edge, if the two vertices are in different trees, union the nodes and add the edge.
    \item Prim's: Create disjoint set for nodes. While there are isolated nodes, iterate through set to get the minimum edge to something we have not visited yet.
\end{itemize}
\subsection{Paths}
\begin{itemize}
    \itemsep0em
    \item Djikstra
    \item Bellman Ford/Floyd Warshall
    \item Matrix multiplication
\end{itemize}
TODO

\subsection{Recursion, Divide and Conquer}
TODO

\subsection{Operating Systems}
\begin{itemize}
    \itemsep0em
    \item Processes - separate address space, more costly to create
    \item Threads - share address space and resources in a process
    \item Concurrency issues - safety refers to never being in deadlock, liveness refers to stop waiting after a certain time.
    \item Locks/Mutex - limits to one thread in a process (binary semaphore) - lock.acquire(), lock.wait(), lock.release()
    \item Semaphores - limits number of processes - semaphore(n), s.up(), s.down()
    \item Monitors/Condition variable - avoid busy waiting by acquiring lock and then releasing it, and getting put on the semaphore queue. Then, when a process is done, it can either signal one or all that the resource is free.
    \item Deadlock - processes waiting for each other. Two people playing tug of war and neither wants to let go. Think of true/false as the lock acquire/release.
    \begin{lstlisting}[language=c]
/* PROCESS 0 */
a = true; 
while (b) {} // gets stuck here
a = false; 

/* PROCESS 1 */
b = true;
while (a) {} // gets stuck here
b = false;
    \end{lstlisting}
    \item Livelock - processes keep responding to each other and neither gets anything done. Two people who keep telling each other ``you first, I'll wait".
\begin{lstlisting}[language=c]
/* PROCESS 0 */
a = true; 
while (b) { // gets stuck in this loop
    a = false;
    // delay
    a = true;
}
a = false; 

/* PROCESS 1 */
b = true;
while (a) { // gets stuck in this loop
    b = false;
    // delay
    b = true;
}
b = false;
\end{lstlisting}
    \item Context switching - switching between threads or processes
    \item Scheduling
    \begin{itemize}
        \item First come first serve - simple and no starvation, but no preemption, so average wait time is long if a process takes a long time.
        \item Shortest job first - high throughput, but unknown job times and may starve long jobs.
        \item Round robin - no starvation, but have to tune quantum length (too long without preemption isn't good, too short makes it inefficient)
        \item Priority - can be flexible based on resources, but requires a separate algorithm for ties, and may starve low priority.
        \item Multi-level feedback queue - similar to priority scheduling, but increase or decrease priority (move to different queue) if starving or hogging.
        \item Round robin - simple, unfair to maringally longer jobs.
        \item Dominant resource fairness - some tasks might be focused on one resource
        %\item Hadoop does FIFO, fair, and capacity scheduling.
        %\item Mesos resource offers.
    \end{itemize}
\end{itemize}

\subsection{System Design, Testing and edge cases}
\begin{itemize}
    \itemsep0em
    \item Breaking down a problem into subproblems
    \item Clarify types of valid/invalid input, input size
    \item Engineering tradeoffs, e.g. time and memory, complexity of solution might be harder to modify
    \item CAP theorem - in distributed systems, the tradeoff between:
    \begin{itemize}
        \item consistency - most recent data or error
        \item availability - no errors, but not necessarily more recent data
        \item partition tolerance - ability to handle data drop. If you cancel the operation, then you are not available but are consistent. On the other hand, if you proceed with the operation, you are available but not consistent.
    \end{itemize}
    \item ACID - database principle, more consistent
    \begin{itemize}
        \item atomicity - all or nothing
        \item consistency - only valid data written
        \item isolation - transactions are independent
        \item durability - no data lost
    \end{itemize}
    \item BASE - database principle, more available
    \begin{itemize}
        \item Basically available
        \item Soft-state
        \item Eventually consistent
    \end{itemize}
    \item DNS for load balancing, CDN caching
    \item Consistent hashing - servers can go in/out of a system, and then you need to move a bunch of data around because your hash based on the number of servers is incorrect. Consistent hashing fixes this, so if a server goes down, only a small amount of entries will need to be moved.
    \item CRUD - create, retrieve, update, delete
\end{itemize}

\subsection{Development Practices and Open-Ended Discussion}
\begin{itemize}
    \itemsep0em
    \item Validating designs
    \item Testing whiteboard code
    \item Preventing bugs
    \item Code maintainability and readability
    \item Refactor/review sample code
    \item Biggest challenge faced
    \item Best/worst design seen
    \item Performance analysis and optimization
    \item Testing and ideas for improving existing products
\end{itemize}

\end{document}
